// Code generated by MockGen. DO NOT EDIT.
// Source: registry.go

// Package registry is a generated GoMock package.
package registry

import (
	tar "archive/tar"
	context "context"
	io "io"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	authn "github.com/google/go-containerregistry/pkg/authn"
	name "github.com/google/go-containerregistry/pkg/name"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	types "github.com/google/go-containerregistry/pkg/v1/types"
	v1beta1 "github.com/kubernetes-sigs/kernel-module-management/api/v1beta1"
	auth "github.com/kubernetes-sigs/kernel-module-management/internal/auth"
)

// MockRegistry is a mock of Registry interface.
type MockRegistry struct {
	ctrl     *gomock.Controller
	recorder *MockRegistryMockRecorder
}

// MockRegistryMockRecorder is the mock recorder for MockRegistry.
type MockRegistryMockRecorder struct {
	mock *MockRegistry
}

// NewMockRegistry creates a new mock instance.
func NewMockRegistry(ctrl *gomock.Controller) *MockRegistry {
	mock := &MockRegistry{ctrl: ctrl}
	mock.recorder = &MockRegistryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRegistry) EXPECT() *MockRegistryMockRecorder {
	return m.recorder
}

// AddLayerToImage mocks base method.
func (m *MockRegistry) AddLayerToImage(tarfile string, image v1.Image) (v1.Image, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddLayerToImage", tarfile, image)
	ret0, _ := ret[0].(v1.Image)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddLayerToImage indicates an expected call of AddLayerToImage.
func (mr *MockRegistryMockRecorder) AddLayerToImage(tarfile, image interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddLayerToImage", reflect.TypeOf((*MockRegistry)(nil).AddLayerToImage), tarfile, image)
}

// ExtractBytesFromTar mocks base method.
func (m *MockRegistry) ExtractBytesFromTar(size int64, tarreader io.Reader) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExtractBytesFromTar", size, tarreader)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExtractBytesFromTar indicates an expected call of ExtractBytesFromTar.
func (mr *MockRegistryMockRecorder) ExtractBytesFromTar(size, tarreader interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExtractBytesFromTar", reflect.TypeOf((*MockRegistry)(nil).ExtractBytesFromTar), size, tarreader)
}

// ExtractFileToFile mocks base method.
func (m *MockRegistry) ExtractFileToFile(destination string, header *tar.Header, tarreader io.Reader) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExtractFileToFile", destination, header, tarreader)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExtractFileToFile indicates an expected call of ExtractFileToFile.
func (mr *MockRegistryMockRecorder) ExtractFileToFile(destination, header, tarreader interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExtractFileToFile", reflect.TypeOf((*MockRegistry)(nil).ExtractFileToFile), destination, header, tarreader)
}

// GetImageByName mocks base method.
func (m *MockRegistry) GetImageByName(imageName string, auth authn.Authenticator) (v1.Image, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetImageByName", imageName, auth)
	ret0, _ := ret[0].(v1.Image)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetImageByName indicates an expected call of GetImageByName.
func (mr *MockRegistryMockRecorder) GetImageByName(imageName, auth interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetImageByName", reflect.TypeOf((*MockRegistry)(nil).GetImageByName), imageName, auth)
}

// GetLayerByDigest mocks base method.
func (m *MockRegistry) GetLayerByDigest(digest string, pullConfig *RepoPullConfig) (v1.Layer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayerByDigest", digest, pullConfig)
	ret0, _ := ret[0].(v1.Layer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLayerByDigest indicates an expected call of GetLayerByDigest.
func (mr *MockRegistryMockRecorder) GetLayerByDigest(digest, pullConfig interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayerByDigest", reflect.TypeOf((*MockRegistry)(nil).GetLayerByDigest), digest, pullConfig)
}

// GetLayerMediaType mocks base method.
func (m *MockRegistry) GetLayerMediaType(image v1.Image) (types.MediaType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayerMediaType", image)
	ret0, _ := ret[0].(types.MediaType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLayerMediaType indicates an expected call of GetLayerMediaType.
func (mr *MockRegistryMockRecorder) GetLayerMediaType(image interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayerMediaType", reflect.TypeOf((*MockRegistry)(nil).GetLayerMediaType), image)
}

// GetLayersDigests mocks base method.
func (m *MockRegistry) GetLayersDigests(ctx context.Context, image string, tlsOptions *v1beta1.TLSOptions, registryAuthGetter auth.RegistryAuthGetter) ([]string, *RepoPullConfig, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayersDigests", ctx, image, tlsOptions, registryAuthGetter)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(*RepoPullConfig)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetLayersDigests indicates an expected call of GetLayersDigests.
func (mr *MockRegistryMockRecorder) GetLayersDigests(ctx, image, tlsOptions, registryAuthGetter interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayersDigests", reflect.TypeOf((*MockRegistry)(nil).GetLayersDigests), ctx, image, tlsOptions, registryAuthGetter)
}

// ImageExists mocks base method.
func (m *MockRegistry) ImageExists(ctx context.Context, image string, tlsOptions *v1beta1.TLSOptions, registryAuthGetter auth.RegistryAuthGetter) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ImageExists", ctx, image, tlsOptions, registryAuthGetter)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ImageExists indicates an expected call of ImageExists.
func (mr *MockRegistryMockRecorder) ImageExists(ctx, image, tlsOptions, registryAuthGetter interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ImageExists", reflect.TypeOf((*MockRegistry)(nil).ImageExists), ctx, image, tlsOptions, registryAuthGetter)
}

// ParseReference mocks base method.
func (m *MockRegistry) ParseReference(imageName string) (name.Reference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParseReference", imageName)
	ret0, _ := ret[0].(name.Reference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParseReference indicates an expected call of ParseReference.
func (mr *MockRegistryMockRecorder) ParseReference(imageName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseReference", reflect.TypeOf((*MockRegistry)(nil).ParseReference), imageName)
}

// VerifyModuleExists mocks base method.
func (m *MockRegistry) VerifyModuleExists(layer v1.Layer, pathPrefix, kernelVersion, moduleFileName string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyModuleExists", layer, pathPrefix, kernelVersion, moduleFileName)
	ret0, _ := ret[0].(bool)
	return ret0
}

// VerifyModuleExists indicates an expected call of VerifyModuleExists.
func (mr *MockRegistryMockRecorder) VerifyModuleExists(layer, pathPrefix, kernelVersion, moduleFileName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyModuleExists", reflect.TypeOf((*MockRegistry)(nil).VerifyModuleExists), layer, pathPrefix, kernelVersion, moduleFileName)
}

// WalkFilesInImage mocks base method.
func (m *MockRegistry) WalkFilesInImage(image v1.Image, fn func(string, *tar.Header, io.Reader, []interface{}) error, data ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{image, fn}
	for _, a := range data {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WalkFilesInImage", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkFilesInImage indicates an expected call of WalkFilesInImage.
func (mr *MockRegistryMockRecorder) WalkFilesInImage(image, fn interface{}, data ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{image, fn}, data...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkFilesInImage", reflect.TypeOf((*MockRegistry)(nil).WalkFilesInImage), varargs...)
}

// WriteImageByName mocks base method.
func (m *MockRegistry) WriteImageByName(imageName string, image v1.Image, auth authn.Authenticator) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteImageByName", imageName, image, auth)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteImageByName indicates an expected call of WriteImageByName.
func (mr *MockRegistryMockRecorder) WriteImageByName(imageName, image, auth interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteImageByName", reflect.TypeOf((*MockRegistry)(nil).WriteImageByName), imageName, image, auth)
}
