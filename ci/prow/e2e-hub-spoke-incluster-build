#!/bin/bash
#
set -euxo pipefail

# Install the `clusteradm` command
curl -L https://raw.githubusercontent.com/open-cluster-management-io/clusteradm/main/install.sh | bash

export MINIKUBE=minikube
export OPERATOR_NAMESPACE=kmm-operator-system

kubectl label node/${MINIKUBE} node-role.kubernetes.io/worker=""

# Init OCM in the cluster
clusteradm init --wait
kubectl wait --for=condition=Available deployment/cluster-manager -n open-cluster-management
kubectl wait --for=condition=Available deployment/cluster-manager-placement-controller -n open-cluster-management-hub
kubectl wait --for=condition=Available deployment/cluster-manager-registration-controller -n open-cluster-management-hub
kubectl wait --for=condition=Available deployment/cluster-manager-registration-webhook -n open-cluster-management-hub
kubectl wait --for=condition=Available deployment/cluster-manager-work-webhook -n open-cluster-management-hub

# Join the "spoke" cluster to the "hub" cluster (in this case a single cluster is both hub and spoke)
token=$(clusteradm get token | grep token= | cut -d"=" -f2-)
hub_api_server=$(kubectl config view -o yaml | yq '.clusters[] | select(.. | .name?=="minikube")' | yq '.cluster.server')
clusteradm join \
  --hub-token ${token} \
  --hub-apiserver ${hub_api_server} \
  --cluster-name ${MINIKUBE}

# Wait for the join command to succeed
kubectl wait --for=condition=Established crd managedclusters.cluster.open-cluster-management.io
timeout 60 sh -c "until kubectl get managedcluster ${MINIKUBE}; do sleep 2; done"
timeout 30 sh -c "until kubectl get csr -l open-cluster-management.io/cluster-name=${MINIKUBE} | grep Pending; do sleep 2; done"
timeout 1m bash -c "until kubectl get csr -l open-cluster-management.io/cluster-name=${MINIKUBE} -o json | jq -er \".items[].metadata.name\"; do sleep 2; done"
kubectl wait --for=condition=Available deployment/klusterlet-registration-agent -n open-cluster-management-agent

clusteradm accept --clusters ${MINIKUBE}

# Installing required addons to the hub/spoke clusters
clusteradm install hub-addon --names application-manager
clusteradm addon enable --names application-manager --clusters ${MINIKUBE}

clusteradm install hub-addon --names governance-policy-framework
clusteradm addon enable --names governance-policy-framework --clusters ${MINIKUBE}

clusteradm addon enable addon --names config-policy-controller --clusters ${MINIKUBE}

# Install kmm and kmm-hub
make deploy-hub
make deploy
kubectl wait --for=condition=Available --timeout=1m deployment/kmm-operator-hub-controller-manager -n ${OPERATOR_NAMESPACE}
kubectl wait --for=condition=Available --timeout=1m deployment/kmm-operator-controller-manager -n ${OPERATOR_NAMESPACE}

echo "Create a build secret..."
oc create secret generic build-secret --from-literal=ci-build-secret=super-secret-value -n ${OPERATOR_NAMESPACE}

echo "Add a configmap that contain the kernel module build dockerfile..."
kubectl apply -f ci/kmm-kmod-dockerfile.yaml -n ${OPERATOR_NAMESPACE}

echo "Add Secrets containing the signing key and certificate..."
kubectl apply -f ci/secret_kmm-kmod-signing.yaml -n ${OPERATOR_NAMESPACE}

# Apply the ManagedClusterModule
kubectl apply -f ci/managedclustermodule-kmm-ci-build-sign.yaml

# Waiting for the manifestwork to be created
timeout 1m bash -c 'until kubectl -n ${MINIKUBE} get manifestwork/kmm-ci; do sleep 1; done'
kubectl get manifestwork/kmm-ci -n ${MINIKUBE} -o yaml | yq '.spec.workload.manifests'

# Validate that the Module has no `build`/`sign` sections
timeout 1m bash -c 'until kubectl -n ${OPERATOR_NAMESPACE} get module/kmm-ci; do sleep 1; done'
kubectl -n ${OPERATOR_NAMESPACE} get module/kmm-ci -o json | \
    jq '.spec.moduleLoader.container.kernelMappings[] | (.build | type) == "null" and (.sign // null | type) == "null"' | grep true
